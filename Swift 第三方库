Swift 第三方库

比如 AFNet  比如 Perfetc  http server


其中 对于 协议 扩展 枚举 的 使用  技巧 登峰造极


回顾 阅读这些源码时  经常遇到 协议

	协议在swift中 作为 数据类型来使用

	协议类型 可以作为函数 方法 或者 构造函数中 的参数类型 或 返回值类型

	协议类型可以作为 常量 变量 或 属性的类型

	协议类型 可以作为数组 字典 Set等集合的元素类型

	这一点 可以 比对 java  中的接口类 这个
	java程序员 传参等 都是传的接口  该接口被多个类 遵从
	swift程序员 传参等 都是传的协议  这个协议 被多个类 结构体 等遵从 
	OC程序员 传参 等 都是传的 一个类的实例 这个类 有父类 可能有多个不同类 继承这个父类

	无形 实现了 各自系统的多态么 运行时多态？？？？

	第一  协议 可以继承 协议的继承 与 类的继承 一样  协议a 继承 协议b  同时 遵从这个协议的类载体 遵守协议a 则 其实载体类 必须遵从两个协议
	实现两个协议规范的方法与属性

	协议的继承 语法规范 与 类继承一样 都使用 冒号: ,如果一个协议需要有多个协议继承 则可以使用,逗号 分隔各个需要继承的协议


	第二 协议 可以扩展

	从语法上看 协议的扩展与类 结构体 等类型的扩展没有什么区别 协议扩展本质还是协议 只不过增加了一些方法 和 属性
	在使用的时候 需要遵从着实现该协议



	第三 扩展某个类或者结构体 并遵从某个协议

	扩展中遵从某个协议

	第四 协议中 有协议静态方法

	协议中定义该静态方法时 需要添加 static 关键字 前缀

	那么遵从者 根据数据类型 如果是类遵从 实现方法时 关键字使用class 如果是结构体就还使用 static 关键字

	使用class遵从者的子类 可以重写该方法
	但是 使用 static 遵从者的子类中不可以重写该静态方法

	第五 协议变异方法

	在协议中 定义变异方法时 方法前要添加mutating 关键字

	类和 结构体 枚举 都可以遵从变异方法
	类遵从变异方法时 前面不需要遵从mutating
	也就是实现时 不需要再写关键字mutating

	而结构体和枚举遵从变异方法时 前面需要添加mutating关键字

	第六 协议中有静态属性

	协议中可以写静态属性 属性前 使用   static 关键字

	那么遵从者 根据数据类型 实现时 需要针对关键字有什么不同设置吗  答案
	竟然是 两者 不管是类 还是 结构体  都和协议一样 使用 static 关键字

	第七 协议中定义 实例属性

	定义属性时 指明数据类型 并且会用大括号 写setter 和 getter访问器 表明 针对该属性 遵从者必须实现 该属性的那个访问器方法

	遵从者 遵从该协议时 针对协议对属性的访问器限制

	必须实现协议要求的访问器  但是也可以多设置

	比如 协议定义  var fullname:String {get} 但是遵从者实现了 get 和 set 两个访问器 也是允许的 但是 必须有get

	对于 协议 var firstName:String {set,get}

   遵从者  var firstName:String = 'ssss'





面向协议的概念  比如 几何图形类可以有绘制图形的方法  但是绘制图形方法的具体内容 无法确定 因为我们都不知道绘制的是什么样的几何图形  矩形子类有自己的绘制方法  圆形子类 有自己的绘制方法
	protocol  Figure  draw

	Ciricle  draw

	Rectangle  draw

我们在传参时 要求接受的是 protocol数据类型 但是只有函数执行到具体业务要画圆 还是 矩形时  根据 接受的protocol的数据类型 向下转型 为 具体数据类型  才能画出想要的

###############扩展 ###########

扩展在Swift中 可以在原始类型中添加新功能


包括 
实例计算属性 和 类型 计算属性

（存储属性 没有实现 大括号 get set访问器的属性 ;
 计算属性  用大括号 写了get set 访问器的属性  ;
 只读计算属性 只写了 get访问器的属性 ; 属性观察者 实现了 willset didset 方法的属性）

实例方法 与 类型方法  

构造函数 

下标运算

上面 也提到 在扩展时 可以遵从协议

###########枚举############

使用枚举成员赋值时 可以采用完整的 枚举类型名.成员值的 形式 也可以省略枚举类型名  而采用.成员值的形式


枚举 相关值  在我们定义枚举数据类型时

与 switch  条件语句 配合使用时

使用到相关值  相关值 取值

enum  Figure {
	case Rectangle(int,int)
	case Circle(int)
}

//注意着里的 Rectangle 可不是类 或者 结构体数据类型  是 相关值  是相关值方法 

//使用该结构体赋值的时候 要.Rectangle(10,10) 赋值给 定义变量 


func printFigure(figure:Figure) {
	
	switch figure {
	case let .Rectangle(let width,let height):

	print("矩形的宽:\(width) 高:\(height)")

	case .Circle(let radius):

	print("圆形半径:\(radius)")

	}

}


var figure = Figure.Rectangle(1024,768)

printFigure(figure)




#####switch if  guard 值绑定####

if 值绑定 语句块 在 值绑定条件为true 时 执行


guard  值绑定  语句块 在 值绑定条件为 false 时 执行  
true 时 往下 执行



#######swift中 array set dic 都是结构体 造成我们 全是值类型 定义结构体类型时  我们如何修改这个结构体类型修改自己的成员 产生 结构体实例对象特权方法 修改自己成员 需要标记关键字 mutating

swift 中 可变 数组 与 不可变数组

可变字典 与 不可变字典 根据 声明时 使用的

var  还是 let 区分


/*
下面我们对值类型数据的 修改 再做一次总结

我们发现结构体 修改自己需要定义 mutating 关键字 

其实 对于任何值类型 还是 引用类型

只是编译器 或者说 我们特定的某个开发语言 自己针对 某个数据类型 做了默认处理

比如 编译器 看到 你定义的是类

那么 在业务层传递 该类实例的对象 或者 传参时

直接按照引用传递的  所以说该数据类型为 引用类型

但是 编译器看到你搞了个结构体 默认 就让它 在业务流 传递该数据的时候 按照值传递方式

那么我们碰到 直接修改结构体 报错 为什么这是编译器层面做的 只是不友好的告诉程序员 你这样直接修改是不起作用的 防患未然 免得跑起来遇到不可预期的错误

struct Department {
	var no:Int = 0
	var name:String = ""
}

var dept = Department()

dept.no = 10

dept.name = "Sales"

dept.no = 11

func updateDept(dept:Depart) {
	dept.name = "Research"
}

print("更新前\(dept.name)")
updateDept(dept)  //这里在xcode 其实已经报错了  提示你 这么做其实是无效的 需要指定 inout 关键字 用引用传递
print("更新后\(dept.name)")
//修改
func updateDept(inout dept:Depart) {
	dept.name = "Research"
}
updateDept(&dept)


那么 引申到 结构体的 在结构体定义时候 内部定义 变异方法 修改自己的成员 

因为 高级的swift  对结构体 多了 self 这个自我引用关键字

因此在 结构体定义方法时  可以引用到 当前调用该结构体方法的实例结构体 自己

从而 想做修改  这里帮程序员 省了 inout 麻烦编程 简化编程结构

因此我们程序员需要配合的就是 声明方法时 加关键字 mutating




而类 属于引用类型 swift  类似于 C++与OC中的对象指针类型


我们明确亮点 程序是自己的 能访问到变量地址 就能修改  变量的值 所以值类型的 结构体

只要不是常量  也是能修改的 

能随时修改实例的结构体的数据的 只是修改的方法要对 inout 还是 mutating

另外 注意结构体 定义为let 常量 不可以修改

//        let dept = Department()
//        dept.no = 10
//        dept.name = "Sales"

那么我们总结 常量的 值类型数据 程序员无法修改


变量的 值类型数据 我们可以修改

常量的 引用类型数据 我们不可以修改自己 但是 可以修改该引用类型数据的 成员变量

变量的 引用数据类型 更不用说了 

程序员可以修改常量 吗  不可以  这是程序员做不到的  系统常量 更做不到

*/

#######


####### 嵌套函数  与闭包 都可以 访问它所在上下文的变量与常量  即便这些常量与 变量的原始作用域已经不存在了 嵌套函数 与 闭包 仍然可以 在函数体内 或闭包体内 获取到这些值  但是 不能修改 只是截获而已 如果需要与外部的 数据交互 需要其他关键字 技术 还要特别注意 闭包 在原始作用域结束后 闭包 截获 造成循环引用 #######


嵌套函数 与 闭包 看到了 javascript  设计模式 的影子
